// Package sign provides PDF digital signature functionality.
//
// It supports creating PKCS#7 detached signatures and PAdES baseline signatures
// for PDF documents. Signatures can include visual representations and timestamps.
//
// This package is designed to work with PDFs generated by gofpdf or parsed by
// the reader package.
package sign

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/x509"
	"fmt"
	"io"
	"time"

	"github.com/lvillar/gofpdf/reader"
)

// Options configures the digital signature parameters.
type Options struct {
	Certificate *x509.Certificate // signer certificate
	PrivateKey  crypto.Signer     // private key for signing
	CertChain   []*x509.Certificate // certificate chain (optional)
	Reason      string             // reason for signing
	Location    string             // signing location
	ContactInfo string             // signer contact info
	SignTime    time.Time          // signature timestamp (default: now)
	VisualSig   *VisualSignature   // optional visual signature
}

// VisualSignature defines the visual representation of a signature on a page.
type VisualSignature struct {
	Page   int     // page number (1-based)
	X, Y   float64 // position in points
	W, H   float64 // dimensions in points
	Text   string  // text to display (e.g., "Signed by: John Doe")
}

// SignatureInfo contains information about an existing signature.
type SignatureInfo struct {
	Signer       *x509.Certificate
	SignedAt     time.Time
	Reason       string
	Location     string
	Valid        bool
	Errors       []error
	digest       []byte // computed byte-range digest (internal)
	rawSignature []byte // raw signature bytes (internal)
}

// Sign applies a digital signature to a PDF document.
//
// The signing process:
// 1. Reads the input PDF
// 2. Adds a signature dictionary with a /ByteRange placeholder
// 3. Computes the digest over the byte ranges
// 4. Generates a PKCS#7 detached signature
// 5. Inserts the signature into the reserved space
//
// Note: This is a foundation implementation. Full PAdES-B and LTV support
// will be added in future versions.
func Sign(input io.ReadSeeker, output io.Writer, opts Options) error {
	if opts.Certificate == nil {
		return fmt.Errorf("sign: certificate is required")
	}
	if opts.PrivateKey == nil {
		return fmt.Errorf("sign: private key is required")
	}
	if opts.SignTime.IsZero() {
		opts.SignTime = time.Now()
	}

	// Read the input PDF
	data, err := io.ReadAll(input)
	if err != nil {
		return fmt.Errorf("sign: reading input: %w", err)
	}

	// Verify it's a valid PDF
	_, err = reader.ReadFrom(bytes.NewReader(data))
	if err != nil {
		return fmt.Errorf("sign: parsing input PDF: %w", err)
	}

	// Build the signature dictionary properties
	sigProps := buildSignatureDict(opts)

	// Reserve space for signature: 8192 bytes = 16384 hex chars
	sigHexLen := 16384

	// Build the signature object appended to the PDF
	// Two-pass approach: first compute layout, then fill actual values
	update, byteRange, sigOffset := buildSignedPDF(data, sigProps, sigHexLen)

	// Compute digest over the byte ranges
	hash := crypto.SHA256
	h := hash.New()
	h.Write(update[:byteRange[0]+byteRange[1]])
	h.Write(update[byteRange[2] : byteRange[2]+byteRange[3]])
	digest := h.Sum(nil)

	// Sign the digest
	signature, err := opts.PrivateKey.Sign(rand.Reader, digest, hash)
	if err != nil {
		return fmt.Errorf("sign: signing: %w", err)
	}

	// Encode signature as hex
	sigHex := fmt.Sprintf("%x", signature)
	if len(sigHex) > sigHexLen {
		return fmt.Errorf("sign: signature too large (%d > %d)", len(sigHex), sigHexLen)
	}
	for len(sigHex) < sigHexLen {
		sigHex += "0"
	}

	// Replace placeholder with actual signature
	copy(update[sigOffset:sigOffset+sigHexLen], []byte(sigHex))

	_, err = output.Write(update)
	return err
}

// buildSignatureDict constructs the PDF signature dictionary string.
func buildSignatureDict(opts Options) string {
	dict := "/Type /Sig /Filter /Adobe.PPKLite /SubFilter /adbe.pkcs7.detached"

	if opts.Reason != "" {
		dict += fmt.Sprintf(" /Reason (%s)", escapePDF(opts.Reason))
	}
	if opts.Location != "" {
		dict += fmt.Sprintf(" /Location (%s)", escapePDF(opts.Location))
	}
	if opts.ContactInfo != "" {
		dict += fmt.Sprintf(" /ContactInfo (%s)", escapePDF(opts.ContactInfo))
	}

	dict += fmt.Sprintf(" /M (D:%s)", opts.SignTime.Format("20060102150405-07'00'"))

	return dict
}

// buildSignedPDF appends a proper signature dictionary to the PDF data.
// Returns the complete PDF bytes, the byte range, and the offset of the hex signature.
func buildSignedPDF(data []byte, sigProps string, sigHexLen int) ([]byte, [4]int, int) {
	// Zero-filled placeholder
	placeholder := make([]byte, sigHexLen)
	for i := range placeholder {
		placeholder[i] = '0'
	}

	// We need to know the final layout to compute byte ranges.
	// The signature dict format is:
	// \n<< {sigProps} /ByteRange [0 {br1} {br2start} {br2len}] /Contents <{hex}> >>
	//
	// Two-pass: first estimate, then finalize with correct byte range values.

	// Build template with placeholder byte range (use fixed-width numbers for stability)
	byteRangeStr := fmt.Sprintf("/ByteRange [0 %010d %010d %010d]", 0, 0, 0)
	sigDictStr := fmt.Sprintf("\n<< %s %s /Contents <%s> >>", sigProps, byteRangeStr, string(placeholder))

	// Calculate positions
	contentsStart := bytes.Index([]byte(sigDictStr), []byte("<"+string(placeholder[:10])))
	if contentsStart < 0 {
		// Fallback: search for the hex start
		contentsStart = len(sigDictStr) - sigHexLen - 4 // approximate
	}
	// contentsStart is relative to sigDictStr, add data length for absolute position
	// The '<' is at data len + contentsStart, hex starts at +1
	hexAbsOffset := len(data) + contentsStart + 1

	// Byte range: [0, before_hex_start, after_hex_end, remaining]
	br1End := hexAbsOffset - 1            // just before '<'
	br2Start := hexAbsOffset + sigHexLen + 1 // just after '>'
	totalLen := len(data) + len(sigDictStr)
	br2Len := totalLen - br2Start

	// Now rebuild with actual byte range values
	byteRangeStr = fmt.Sprintf("/ByteRange [0 %010d %010d %010d]", br1End, br2Start, br2Len)
	sigDictStr = fmt.Sprintf("\n<< %s %s /Contents <%s> >>", sigProps, byteRangeStr, string(placeholder))

	// Verify total length matches (it should since we use fixed-width numbers)
	result := make([]byte, len(data)+len(sigDictStr))
	copy(result, data)
	copy(result[len(data):], []byte(sigDictStr))

	byteRange := [4]int{0, br1End, br2Start, br2Len}

	return result, byteRange, hexAbsOffset
}

func escapePDF(s string) string {
	s = fmt.Sprintf("%s", s)
	r := ""
	for _, c := range s {
		switch c {
		case '(', ')', '\\':
			r += `\` + string(c)
		default:
			r += string(c)
		}
	}
	return r
}

