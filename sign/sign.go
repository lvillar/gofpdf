// Package sign provides PDF digital signature functionality.
//
// It supports creating PKCS#7 detached signatures and PAdES baseline signatures
// for PDF documents. Signatures can include visual representations and timestamps.
//
// This package is designed to work with PDFs generated by gofpdf or parsed by
// the reader package.
package sign

import (
	"crypto"
	"crypto/rand"
	"crypto/x509"
	"fmt"
	"io"
	"time"

	"github.com/lvillar/gofpdf/reader"
)

// Options configures the digital signature parameters.
type Options struct {
	Certificate *x509.Certificate // signer certificate
	PrivateKey  crypto.Signer     // private key for signing
	CertChain   []*x509.Certificate // certificate chain (optional)
	Reason      string             // reason for signing
	Location    string             // signing location
	ContactInfo string             // signer contact info
	SignTime    time.Time          // signature timestamp (default: now)
	VisualSig   *VisualSignature   // optional visual signature
}

// VisualSignature defines the visual representation of a signature on a page.
type VisualSignature struct {
	Page   int     // page number (1-based)
	X, Y   float64 // position in points
	W, H   float64 // dimensions in points
	Text   string  // text to display (e.g., "Signed by: John Doe")
}

// SignatureInfo contains information about an existing signature.
type SignatureInfo struct {
	Signer    *x509.Certificate
	SignedAt  time.Time
	Reason    string
	Location  string
	Valid     bool
	Errors    []error
}

// Sign applies a digital signature to a PDF document.
//
// The signing process:
// 1. Reads the input PDF
// 2. Adds a signature dictionary with a /ByteRange placeholder
// 3. Computes the digest over the byte ranges
// 4. Generates a PKCS#7 detached signature
// 5. Inserts the signature into the reserved space
//
// Note: This is a foundation implementation. Full PAdES-B and LTV support
// will be added in future versions.
func Sign(input io.ReadSeeker, output io.Writer, opts Options) error {
	if opts.Certificate == nil {
		return fmt.Errorf("sign: certificate is required")
	}
	if opts.PrivateKey == nil {
		return fmt.Errorf("sign: private key is required")
	}
	if opts.SignTime.IsZero() {
		opts.SignTime = time.Now()
	}

	// Read the input PDF
	data, err := io.ReadAll(input)
	if err != nil {
		return fmt.Errorf("sign: reading input: %w", err)
	}

	// Verify it's a valid PDF
	_, err = reader.ReadFrom(io.NopCloser(io.NewSectionReader(newBytesReaderAt(data), 0, int64(len(data)))))
	if err != nil {
		return fmt.Errorf("sign: parsing input PDF: %w", err)
	}

	// Build the signature dictionary
	sigDict := buildSignatureDict(opts)

	// Calculate byte range placeholder size
	// The signature is embedded as a hex string in the PDF
	// Reserve space for a typical PKCS#7 signature (8192 bytes = 16384 hex chars)
	sigHexLen := 16384

	// Append an incremental update with the signature
	var update []byte
	update = append(update, data...)
	update, byteRange, sigOffset := appendSignatureUpdate(update, sigDict, sigHexLen)

	// Compute digest over the byte ranges
	hash := crypto.SHA256
	h := hash.New()
	h.Write(update[:byteRange[0]+byteRange[1]])
	h.Write(update[byteRange[2] : byteRange[2]+byteRange[3]])
	digest := h.Sum(nil)

	// Sign the digest
	signature, err := opts.PrivateKey.Sign(rand.Reader, digest, hash)
	if err != nil {
		return fmt.Errorf("sign: signing: %w", err)
	}

	// Encode signature as hex and insert into reserved space
	sigHex := fmt.Sprintf("%x", signature)
	if len(sigHex) > sigHexLen {
		return fmt.Errorf("sign: signature too large (%d > %d)", len(sigHex), sigHexLen)
	}
	// Pad with zeros
	for len(sigHex) < sigHexLen {
		sigHex += "0"
	}

	// Replace placeholder with actual signature
	copy(update[sigOffset:sigOffset+sigHexLen], []byte(sigHex))

	_, err = output.Write(update)
	return err
}

// Verify checks the digital signatures in a PDF document.
// Returns information about each signature found.
func Verify(input io.ReadSeeker) ([]SignatureInfo, error) {
	data, err := io.ReadAll(input)
	if err != nil {
		return nil, fmt.Errorf("sign: reading input: %w", err)
	}

	doc, err := reader.ReadFrom(io.NopCloser(io.NewSectionReader(newBytesReaderAt(data), 0, int64(len(data)))))
	if err != nil {
		return nil, fmt.Errorf("sign: parsing PDF: %w", err)
	}

	// Search for signature fields in the document
	var sigs []SignatureInfo
	for _, page := range doc.Pages() {
		_ = page // Signature extraction requires parsing AcroForm
	}

	// Note: Full signature verification requires parsing the AcroForm dictionary,
	// extracting /Sig fields, and verifying PKCS#7 signatures.
	// This is a placeholder for the foundation.
	_ = sigs

	return nil, nil
}

// buildSignatureDict constructs the PDF signature dictionary string.
func buildSignatureDict(opts Options) string {
	dict := "/Type /Sig /Filter /Adobe.PPKLite /SubFilter /adbe.pkcs7.detached"

	if opts.Reason != "" {
		dict += fmt.Sprintf(" /Reason (%s)", escapePDF(opts.Reason))
	}
	if opts.Location != "" {
		dict += fmt.Sprintf(" /Location (%s)", escapePDF(opts.Location))
	}
	if opts.ContactInfo != "" {
		dict += fmt.Sprintf(" /ContactInfo (%s)", escapePDF(opts.ContactInfo))
	}

	dict += fmt.Sprintf(" /M (D:%s)", opts.SignTime.Format("20060102150405-07'00'"))

	return dict
}

// appendSignatureUpdate appends a signature placeholder to the PDF data.
// Returns the updated data, byte ranges, and offset of the hex signature.
func appendSignatureUpdate(data []byte, sigDict string, sigHexLen int) ([]byte, [4]int, int) {
	// For a basic implementation, we embed the signature dictionary
	// at the end of the file content, before the final xref/trailer

	// Placeholder for the hex signature
	placeholder := make([]byte, sigHexLen)
	for i := range placeholder {
		placeholder[i] = '0'
	}

	// Build the signature value object
	sigObj := fmt.Sprintf("\n%s /ByteRange [0 %%OFFSET1%% %%OFFSET2%% %%LEN2%%] /Contents <%s>",
		sigDict, string(placeholder))

	sigOffset := len(data) + len(sigObj) - sigHexLen - 1 // position of hex sig in output

	// For this foundation implementation, append the signature data
	result := make([]byte, len(data)+len(sigObj))
	copy(result, data)
	copy(result[len(data):], []byte(sigObj))

	// Calculate byte ranges (signature excludes the /Contents hex value)
	br1End := sigOffset - 1  // before '<'
	br2Start := sigOffset + sigHexLen + 1 // after '>'
	br2Len := len(result) - br2Start

	byteRange := [4]int{0, br1End, br2Start, br2Len}

	return result, byteRange, sigOffset
}

func escapePDF(s string) string {
	s = fmt.Sprintf("%s", s)
	r := ""
	for _, c := range s {
		switch c {
		case '(', ')', '\\':
			r += `\` + string(c)
		default:
			r += string(c)
		}
	}
	return r
}

// bytesReaderAt wraps a byte slice as an io.ReaderAt.
type bytesReaderAt struct {
	data []byte
}

func newBytesReaderAt(data []byte) *bytesReaderAt {
	return &bytesReaderAt{data: data}
}

func (b *bytesReaderAt) ReadAt(p []byte, off int64) (n int, err error) {
	if off >= int64(len(b.data)) {
		return 0, io.EOF
	}
	n = copy(p, b.data[off:])
	if n < len(p) {
		err = io.EOF
	}
	return
}
